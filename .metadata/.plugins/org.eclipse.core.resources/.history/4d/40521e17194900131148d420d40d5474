import java.util.ArrayList;

/**
 * @author: Fabrizio Niedda
 * @version: 1.0
 * @description: Represents a {@link GameLine} and offers some basic functions to deal with them.
 * A {@link GameLine} always contains 3 {@link GameField}.  
 */
public class GameLine {
		
	//Privates
	private GameLine(GameField field1, GameField field2, GameField field3) {
		_field1 = field1;
		_field2 = field2;
		_field3 = field3;
	}
	
	private GameField _field1;
	
	private GameField _field2;
	
	private GameField _field3;
		
	
	//Getters
	public GameField getField1() {
		return _field1;
	}
	
	public GameField getField2() {
		return _field2;
	}
	
	public GameField getField3() {
		return _field3;
	}
	
	//Publics
	/**
	 * Get the {@link GameField} of the line. 
	 * @return {@link GameField}
	 */
	public ArrayList<GameField> getGameFields() {
		ArrayList<GameField> fields = new ArrayList<GameField>();
		fields.add(getField1());
		fields.add(getField2());
		fields.add(getField3());
		return fields;
	}
	
	/**
	 * Evaluates if the line contains the {@link GameField}.
	 * @param field The {@link GameField} to check for. 
	 * @return boolean
	 */
	public boolean contains(GameField field) {
		return field.getXPosition() == _field1.getXPosition() && field.getYPosition() == _field1.getYPosition() ||
				field.getXPosition() == _field2.getXPosition() && field.getYPosition() == _field2.getYPosition() ||
				field.getXPosition() == _field3.getXPosition() && field.getYPosition() == _field3.getYPosition();
	}
	
	/**
	 * Get the minimum moves needed to win the game.
	 * @param fieldsOwned The fields owned.
	 * @return int
	 */
	public int getMovesNeeded(ArrayList<GameField> fieldsOwned) {
		int fieldCountNeeded = 3;
		int fieldCountOwned = 0;
		
		for(GameField field: fieldsOwned) {
			if(field.equals(getField1())) {
				fieldCountOwned++;
			}
			if(field.equals(getField2())) {
				fieldCountOwned++;
			}
			if(field.equals(getField3())) {
				fieldCountOwned++;
			}
		}		
		return fieldCountNeeded - fieldCountOwned;
	}	
	
	//Statics
	/**
	 * Get the available {@link GameLine} still available.
	 * @param tokenFields The fields already token by the player.
	 * @return A list of {@link GameLine}.
	 */
	public static ArrayList<GameLine> getFreeLines(ArrayList<GameField> tokenFields) {
		if(tokenFields.size() == 0) {
			//If there's no field taken just return the whole list.
			return getPossibleGameLines();
		}
		ArrayList<GameLine> resultList = getPossibleGameLines();
		ArrayList<GameLine> lines = getPossibleGameLines();		

		//Check the line versus the token fields.
		for (int i = 0; i < 8; i++) {			
			for(GameField field: tokenFields) {	
				//If the line contains a token field remove it from the result list.
				if(lines.get(i).contains(field)) {
					resultList.remove(lines.get(i));
					break;
				}					
			}			
		}
		return resultList;
	}
		
	/**
	 * Get the list of all possible {@link GameLine}.
	 * @return A list of {@link GameLine}.
	 */
	public static ArrayList<GameLine> getPossibleGameLines() {
		GameField[][] playground = Context.getContext().getPlayground();
		ArrayList<GameLine> lines = new ArrayList<>();
		lines.add(new GameLine(new GameField(0, 0, playground[0][0].getValue()), new GameField(1, 1, playground[1][1].getValue()), new GameField(2, 2, playground[2][2].getValue())));
		lines.add(new GameLine(new GameField(0, 2, playground[0][2].getValue()), new GameField(1, 1, playground[1][1].getValue()), new GameField(2, 0, playground[2][0].getValue())));
		
		lines.add(new GameLine(new GameField(0, 0, playground[0][0].getValue()), new GameField(0, 1, playground[0][1].getValue()), new GameField(0, 2, playground[0][2].getValue())));
		lines.add(new GameLine(new GameField(1, 0, playground[1][0].getValue()), new GameField(1, 1, playground[1][1].getValue()), new GameField(1, 2, playground[1][2].getValue())));
		lines.add(new GameLine(new GameField(2, 0, playground[2][0].getValue()), new GameField(2, 1, playground[2][1].getValue()), new GameField(2, 2, playground[2][2].getValue())));
		
		lines.add(new GameLine(new GameField(0, 0, playground[0][0].getValue()), new GameField(1, 0, playground[1][0].getValue()), new GameField(2, 0, playground[2][0].getValue())));
		lines.add(new GameLine(new GameField(0, 1, playground[0][1].getValue()), new GameField(1, 1, playground[1][1].getValue()), new GameField(2, 1, playground[2][1].getValue())));
		lines.add(new GameLine(new GameField(0, 2, playground[0][2].getValue()), new GameField(1, 2, playground[1][2].getValue()), new GameField(2, 2, playground[2][2].getValue())));
		return lines;
	}
}